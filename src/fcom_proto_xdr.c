/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "fcom_proto.h"
/* $Id: fcom_proto.x,v 1.1.1.1 2009/07/28 17:57:06 strauman Exp $ */
#define xdr_uint32_t xdr_u_int
/* No point in transporting 16-bit integers.
 * XDR demands that these be encoded in 4 bytes
 */

bool_t
xdr_FcomVersion (XDR *xdrs, FcomVersion *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomType (XDR *xdrs, FcomType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomUint32 (XDR *xdrs, FcomUint32 *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->FcomUint32_val, (u_int *) &objp->FcomUint32_len, ~0,
		sizeof (uint32_t), (xdrproc_t) xdr_uint32_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomInt32 (XDR *xdrs, FcomInt32 *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->FcomInt32_val, (u_int *) &objp->FcomInt32_len, ~0,
		sizeof (int32_t), (xdrproc_t) xdr_int32_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomInt8 (XDR *xdrs, FcomInt8 *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->FcomInt8_val, (u_int *) &objp->FcomInt8_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomFloat (XDR *xdrs, FcomFloat *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->FcomFloat_val, (u_int *) &objp->FcomFloat_len, ~0,
		sizeof (float), (xdrproc_t) xdr_float))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomDouble (XDR *xdrs, FcomDouble *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->FcomDouble_val, (u_int *) &objp->FcomDouble_len, ~0,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomIt (XDR *xdrs, FcomIt *objp)
{
	register int32_t *buf;

	 if (!xdr_FcomType (xdrs, &objp->_type))
		 return FALSE;
	switch (objp->_type) {
	case FCOM_T_UINT32:
		 if (!xdr_FcomUint32 (xdrs, &objp->FcomIt_u._fc_u32))
			 return FALSE;
		break;
	case FCOM_T_INT32:
		 if (!xdr_FcomInt32 (xdrs, &objp->FcomIt_u._fc_i32))
			 return FALSE;
		break;
	case FCOM_T_FLOAT:
		 if (!xdr_FcomFloat (xdrs, &objp->FcomIt_u._fc_flt))
			 return FALSE;
		break;
	case FCOM_T_DOUBLE:
		 if (!xdr_FcomDouble (xdrs, &objp->FcomIt_u._fc_dbl))
			 return FALSE;
		break;
	case FCOM_T_INT8:
		 if (!xdr_FcomInt8 (xdrs, &objp->FcomIt_u._fc_i08))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_FcomBlobV1_XDR_ (XDR *xdrs, FcomBlobV1_XDR_ *objp)
{
	register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->idnt))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->res3))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->tsHi))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->tsLo))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->stat))
		 return FALSE;
	 if (!xdr_FcomIt (xdrs, &objp->data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FcomBlob_XDR_ (XDR *xdrs, FcomBlob_XDR_ *objp)
{
	register int32_t *buf;

	 if (!xdr_FcomVersion (xdrs, &objp->vers))
		 return FALSE;
	switch (objp->vers) {
	case FCOM_P_VERSION_11:
	case FCOM_P_VERSION_12:
		 if (!xdr_FcomBlobV1_XDR_ (xdrs, &objp->FcomBlob_XDR__u._v1))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_FcomMsg_XDR_ (XDR *xdrs, FcomMsg_XDR_ *objp)
{
	register int32_t *buf;

	 if (!xdr_FcomVersion (xdrs, &objp->vers))
		 return FALSE;
	switch (objp->vers) {
	case FCOM_P_VERSION_11:
	case FCOM_P_VERSION_12:
		 if (!xdr_array (xdrs, (char **)&objp->FcomMsg_XDR__u.fcm_blobs.fcm_blobs_val, (u_int *) &objp->FcomMsg_XDR__u.fcm_blobs.fcm_blobs_len, ~0,
			sizeof (FcomBlob_XDR_), (xdrproc_t) xdr_FcomBlob_XDR_))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
