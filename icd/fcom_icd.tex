\documentclass[11pt]{article}

\usepackage{subfigure}
\usepackage[usenames]{color}
\usepackage{listings}
\lstset{basicstyle=\tt\small}

\usepackage{lcls-article}

\lclsdocumenttype{ICD}
\lclsdocumentnumber{}
\systemname{}

\newcommand{\fcom}{FCOM}

\newcommand{\blob}{blob}
\newcommand{\Blob}{Blob}
\newcommand{\group}{group}
\newcommand{\Group}{Group}
\newcommand{\signal}{signal}
\newcommand{\Signal}{Signal}
\newcommand{\set}{set}
\newcommand{\Set}{Set}

\newcommand{\cstl}[1]{{\lstinline+#1+}}

\newcommand{\note}[1]{
	\begin{description}
		\item[NOTE] #1
	\end{description}
}

\newcommand{\example}[1]{
	\begin{description}
		\item[EXAMPLE] #1
	\end{description}
}


\title{LCLS Fast Feedback Communication Infrastructure Interface Control Document}
\author{Till Straumann}
\date{July 10, 2009}
% \addreviewer{who}{what}

\summary{%
The \acf{\fcom} provides hard- and software infrastructure 
implementing a low-latency, dedicated communication path for feedback
and other applications.%
}

\renewcommand{\revnum}{DRAFT-0-1}

\addchangehistory{000}{April 23, 2009}{All}{DRAFT}
\addchangehistory{001}{June 9, 2009}{All}{Added protocol version number}
\addchangehistory{002}{July 9, 2009}{All}{Added synchronous reception, error processing,
                                          statistics, initialization. Removed FCOM specific 
                                          bits from a blob's status word.}
\addchangehistory{003}{March 19, 2010}{All}{Added fcomDumpIDStats() diagnostic
                                            entry point.}
\addchangehistory{004}{April 21, 2010}{All}{Added fcomDumpBlob() diagnostics entry point.
                                           Added fcomAllocBlobSet(), fcomGetBlobSet(),
                                           fcomFreeBlobSet.
                                           }

\currentrevision{4}

%
\keywords{\fcom}


\begin{document}
\maketitle
\section{Introduction}
In a large distributed control system some applications
require data to be shipped between remote nodes in a
deterministic way with low-latency. While the standard
TCP/IP network provides the necessary connectivity
it is inherently non-deterministic. A lot of hardware
(physical network) and software infrastructure (drivers,
network stack) is shared between applications which makes
the real-time behavior unpredictable.

In particular, a protocol that is designed to 
provide reliability (e.g., TCP/Channel-Access) 
is likely to exhibit non-deterministic timing
because of flow-control, segmentation, retransmission
and other features required to guarantee reliability.

This document describes the interfaces between
a proposed IP-Multicast/UDP based communication protocol,
``\fcom{}'', and the application 
and between internal layers. In order to reduce latencies
dedicated networking hardware and software which are both
entirely decoupled from the standard TCP/IP facilities
shall be employed.

\section{Definition of Terms}
The following terms are used throughout this document
\begin{description}

\item[\Signal]
   A {\em \signal} is a control-system parameter analogous
   to an EPICS PV but since \fcom{} is not within the
   scope of EPICS we want to avoid the term PV.
\item[\Blob]
   A {\em \blob} is an elementary unit of data shipped
   by \fcom{}. It holds the ``value''%
\footnote{
   ``Value'' in this context includes attributes of
   data such as timestamp, type etc.
}
   either read from
   a \signal{} or destined to be written to a \signal{}.
\item[\Group]
   A {\em \group} is a compound of \blob{}s which is bundled
   together for transmission.
\item[\Set]
   A {\em \set} of \blob{}s is an object comprising multiple
   \blob{}s bundled for reception. A single thread can block
   until all requested members of the \set{} update.
\item[Nodes and Endpoints]
   A {\em node} is defined as a computer
   system which is ``participating'' in \fcom{}
   (see sect.~\ref{lbl:participate}, {\em Connectivity}).
   An {\em endpoint} is a logical entity
   that is either a source or a sink of data. Multiple
   endpoints (of either flavor) may be present on a
   single node.
\item[Frame]
   The terms {\em frame} or {\em packet} refer to
   Ethernet frames.
\end{description}

\section{Functional Requirements}
The services of \fcom{} can be visualized as a
``newsletter'' publishing service. There are
`'sources'' of data (the editors) and ``sinks''
(the readers). Readers have to subscribe to receive
a copy of the newsletter and they periodically
have to check their mailboxes to see if a new
letter has arrived. Data flow is essentially
unidirectional.

More formally, the following functional requirements have been
defined:
\begin{description}
\item[Technology]   \fcom{} shall be built on Gigabit Ethernet Technology.

\item[Connectivity] \fcom{} shall provide connectivity between participating
                    nodes for communication of \signal{}s.
\label{lbl:participate}

                    A node is ``participating'' in \fcom{} if it is
                    \begin{itemize}
                       \item physically connected to the GiGE LAN that provides
                       the physical connections.
                       \item running the necessary software to support
                       the \fcom{} protocol.
                    \end{itemize}

\item[Data Format]  \fcom{} shall ship \blob{}s in an atomical fashion.
                    A single \blob{} is comprised of
                    \begin{itemize}
                       \item protocol version information
                       \item a unique identifier
                       \item data type and count information
                       \item a timestamp
                       \item status/quality information
                       \item an array of ``count'' elements of the basic
                             data type ``type''
                    \end{itemize}
                    At least the basic types \cstl{uint32\_t}, \cstl{int32\_t},
                    \cstl{float} and \cstl{double} shall be supported.

					The timestamp and other information apply to all
                    the individual elements of a \blob{}.

                    \note{The maximum size of the representation of a \blob{}
                    is limited. It may not exceed the size of an Ethernet
                    datagram excluding any protocol headers%
\footnote{If, as explained below, for efficiency reasons \blob{}s are
bundled into \group{}s then the size limit applies to the entire \group{}.}.}

                    The semantics of the data are transparent
                    to \fcom{} and entirely defined by the application.

\item[Representation] Given the possibility that \fcom{} may interconnect
                    a heterogeneous set of computer systems the
                    usual problems with compatibility of data
                    representation (endian-ness, floating-point format etc.) 
                    arise. \fcom{} shall address these issues so that
                    the elementary data types are converted on each
                    node into their native representation.

\item[Data Flow]    Data flow is initiated by the source endpoint and
                    cached by \fcom{} on the sink node(s). Data sink 
                    endpoints retrieve data from this cache.

                    \note{There is no requirement for asynchronous
                    notification of endpoints (e.g., via callbacks)
                    but such a feature {\em may} be added in the future.}

					\note{There is no requirement for data-sink
                    endpoints to be able to ``enforce'' the source
                    to produce new data. In fact, data-sink endpoints
                    require no control whatsoever over when data
                    are produced.}

\item[Subscription]
                    The implementation {\em may} require data-sink
                    endpoints to {\em subscribe} to \fcom{} prior
                    to being able to receive data.

                    Subscription is considered a ``configuration''
                    feature which does not require deterministic
                    timing.

                    The implementation {\em may} request data-sink
                    endpoints to cancel subscription when the
                    service is no longer needed.

\item[Multidrop]    \Blob{}s that originate at any data-source endpoint
                    shall be delivered to any data-sink endpoint that wants
                    to receive them. There may be multiple sinks
                    subscribing to a single \blob{}. The sinks may
                    reside on any set of nodes.

\item[Grouping]     Because of the Ethernet requirement
                    the implementation {\em may} -- for
                    efficiency reasons -- {\em require}
                    the definition of {\em \group{}s} of
                    \blob{}s which are transmitted in a single
                    Ethernet frame.
 
\item[Latency]      \fcom{} makes a best-effort attempt to deliver 
                    a \blob{} from source to sink endpoint in 
                    less than 500us. Due to the complexity
                    of Ethernet technology which was not
                    designed with deterministic timing in mind
                    the author does not see how a design
                    could {\em guarantee} a hard limit on
                    latency.

                    At the time of this writing -- after consultation
                    with other experts from SLAC and CISCO -- there
                    are still open questions as to the scalability
                    of IP multicast on a LAN.
\item[Error Handling] The \fcom{} API shall define a consistent way
                    for determining if a service request (e.g.,
                    subscription, transmission, data retrieval, etc.)
                    was successful and shall provide some means
                    for applications to determine the reason of failure.
\item[Diagnostics]  \fcom{} should provide statistical information for
                    diagnostic purposes.
\end{description}

\section{Architectural Overview}
\fcom{} is designed to provide the necessary software infrastructure
for meeting the functional requirements. We propose to use a ``layered''
approach for implementing \fcom{}. The application layer presents
an interface to application programs which hides (most of) the
details of the underlying communication protocols. In fact,
it may turn out that for efficiency reasons some of the lower
layers might have to be changed, collapsed or eliminated but such
modifications of the design are transparent to application 
programs.

At the application layer, the user simply writes and/or reads
\blob{}s of data without having to bother with the details
of the communication, e.g., with addressing, marshalling etc.

At the lower levels, we propose to use well-known protocols
from the TCP/IP world or simplified variants thereof.

\section{Application Layer}
The application layer defines the interface to the user.
This interface should be as simple as possible to use and
configure and hide as much detail as possible.

The interface can be broken into two main parts. One part 
that satisfies producers or ``sources'' of data and a
second part that is used by ``sinks'' or consumers of
data.

In both cases the same simple and yet universal and flexible
data format is used.

The API to the application layer defines the elementary
data layout and routines to group several \blob{}s for
subsequent transmission and to initiate the data transfer.

Consumers of data first must {\em subscribe} in order
to receive data. This will cause \fcom{} to take the
necessary steps to make sure the desired data are
received from the network and cached in memory. 
The API defines a routine for consumers to retrieve
data from the cache.

  \subsection{Design Goals}
    \fcom{} should provide a simple interface for sending
    data from one source to multiple receivers while hiding
    all the details of the underlying transport mechanism.	

    Strict separation of functionality was desired, i.e.,
    no ``knowledge'' about the semantics of the shipped
    data must be built into \fcom.

    All the details of ``addressing'' should also be
    transparent to applications. For sake of simplicity
    it was deemed acceptable to use static/manual 
    configuration tables or files for this purpose.
    These configuration tables/files map a symbolic
    name into an ID which encodes the necessary 
    addressing information. In the future, a directory-lookup
    service could be added.

  \subsection{Data Layout}
    The data layout used by \fcom{} was chosen so that it is
    essentially {\em self-describing}. This allows for a clear
    separation of functionality: \fcom{} can use the embedded
    meta-data (such as `type' and `size' etc.) to properly
    handle marshalling issues and allocate space etc. without
    having to know anything about the semantics of the data
    which are entirely defined by the application. 

    \subsubsection{Elementary Items}
      The elementary entity of data or ``\blob{}'' is composed
      of
      \begin{description}
		\item[Version] Protocol version information composed
              of two pieces, `major' and `minor'. Changes of the
              `major' version imply incompatible changes whereas
              changes of the `minor' version imply backwards-compatible
              extensions.

              E.g., if a receiver was built for version $2.3$ it
              shall reject a \blob{} of version $3.0$ but shall
              accept a \blob{} of version $2.4$. Even though
              certain new features may not be available, the
              implementation guarantees that the subset of
              features of versions $2.3$ and $2.4$ are.

        \item[ID] A universal, unique {\em ID} which is used by 
              sources and sinks to refer to a particular datum.
              \fcom{} locates a \blob{} in its cache based on the ID.

              The IDs are available to application programs as 
              symbolic constants. {\em Their numerical representation
              is defined by \fcom{} and opaque to the application.}

              Applications must not make any assumptions about
              the size of IDs or their semantics.

              \fcom{} defines a data type for IDs which applications
              shall use when they want to store an ID.

              \fcom{} may define macros or subroutines for extracting
              information embedded in IDs as well as for generating
              IDs from other information.

        \item[Timestamp] A timestamp marking the time when the
              datum was produced or when it is to be applied
              (but the exact semantics are defined by the application).

        \item[Status] Status information associated with the datum.
              The semantics are defined by the application.
%              Certain bits in the status word are defined by \fcom{}
%              others are defined by the application. \fcom{} ORs
%              ``it's'' bits into the status word when appropriate.

        \item[Type] An element-type. Currently, the C99 types
              {\tt int8\_t}, {\tt int32\_t}, {\tt uint32\_t}, {\tt float} and
              {\tt double} are supported.

        \item[Count] An element-count. The datum consists of an
              array of elements which all share the same status,
              timestamp, type and ID.
		\item[Alignment]
              \fcom{} guarantees that the array of data elements (``payload'')
              in the cache is properly aligned for access by
              a {\em SIMD} unit if present on a particular CPU architecture.

              When handing \blob{}s to \fcom{} the application is responsible
              for the proper alignment of the \blob{} header and payload.
              However, natural alignment is sufficient but maintaining
              ``vector-alignment'' {\em may} result in higher efficiency.
      \end{description}

    \subsubsection{Grouping}
                    Because of the Ethernet requirement
                    the implementation may require -- for
                    efficiency reasons -- 
                    the definition of {\em \group{}s} of
                    \blob{}s which can be transmitted
                    in a single Ethernet frame.
                     
                    \Group{}s essentially map to IP multicast
                    groups.

                    A \group{} has the following properties:
                    \begin{itemize}
                       \item A \group{} has a unique {\em \group{} ID}.
                       \item Any \blob{} with a given ID is a member
                             of exactly one group. The \group{}
                             ID can therefore be a sub-part of the
                             \blob{}'s ID.

                       \item Multiple \blob{}s belonging to 
                             the same \group{} can 
                             be sent in a single Ethernet frame.

                       \item \Blob{}s belonging to different
                             groups cannot be sent in a single
                             frame.

                       \item When a endpoint subscribes to a
                             particular \blob{} the node hosting
                             the communication endpoint actually
                             subscribes to the \group{} and therefore
                             \fcom{} has to process the entire \group{}
                             (but this fact is hidden from the 
                             receiving endpoint).
                    \end{itemize}

                    From these properties it follows that
                    a smaller group size provides finer grained
                    control at the expense of more and smaller Ethernet
                    frames
                    being sent (but these may not be distributed
                    as widely as bigger groups because they are
                    likely to have less subscribers).

                    A smaller group size increases the total number
                    of groups and thus consumes more resources on
                    the Ethernet switches which have to maintain
                    path information for each individual group.

                    A larger group size reduces the protocol
                    overhead (as long as the sink assembles
                    as many \blob{}s as possible into a single
                    transmission) and the use of resources on the
                    switches for packet routing but larger groups
                    are likely to be more widely distributed which
                    increases overall network load.

                    It shall be the responsibility of the system
                    designer to define a suitable set of \group{}s.

                    \fcom{} defines an upper bound on the number
                    of \group{}s it supports.

                    The \group{} a \blob{} is a member of shall
                    implicitly map to a unique IP multicast address
                    so that the data source and sink both ``know''
                    what IP multicast address to use for communication.

                    \note{Because of the requirement to bundle
                    \blob{}s into \group{}s a particular 
                    setpoint variable may require to be represented
                    in multiple groups: Assume an application wants
                    to control three parameters A, B and C which
                    are grouped into G1. Another application (not
                    executing at the same time) may want to control
                    B,E and F by means of a group G2. Hence, depending
                    on the application, B must be represented in group
                    G1 or G2. Because a single ID can only be a
                    member of a single group {\em two different IDs} 
                    are needed to deal with the situation described
                    above, e.g., G1\_B and G2\_B. The first application
                    would subscribe to the former whereas the alternate
                    application would subscribe to the latter ID.}

	\subsubsection{Sets}
                    The implementation may define {\em blob sets}\/
                    which consist of a set of IDs. An application may
                    retrieve a \set{} in a single operation. \Set{}s allow
                    an application to block for the arrival of new data
                    for all members of the \set{} (or a subset).
                    Such a feature could be very useful if a single
                    thread needs multiple \blob{}s before processing
                    the data contained in them.

	\subsubsection{Configuration}
		Applications need to refer to particular \blob{}s using
        their IDs. Furthermore, \fcom{} needs to determine
        the \group{} a particular \blob{} is a member of.

        It shall be permissible for the implementation
        to use a {\em static database} for this purpose
        of {\em association}. The database (e.g., header file)
        contains definitions of \group{} and \blob{} IDs
        which associate a symbolic name with the numerical
        values of the IDs. Applications use the symbolic
        names when referring to a particular \blob{}.

        The database also defines the composition of \group{}s.

        \Blob{} IDs are composed of a \signal{} part and a \group{}
        part; each part ranges from zero to a maximum defined
        (as symbolic constants) by \fcom. \fcom{} provides
        macros to assemble a \blob{} ID from its parts.

        The numerical IDs 0..7 are reserved.
        
		\example{The \signal{} part of the ID could be split
          into a subsystem/IOC sub-part (10-bit) and a ``PV'' sub-part
          (6-bit) to be defined by the subsystem designer.

          This approach partitions the numerical range of
          \signal{}s so that changes/additions to individual
          subsystems are possible without having to renumber
          (and recompile and restart) everything.

          The \group{} IDs could be defined numerically identical
          to the subsystem/IOC part of the \signal{} part.
          However, note that the \group{} ID indicates
          where a {\em value originates} and the subsystem/IOC
          sub-part indicates where a \signal{} resides.

          For a ``detector'' \signal{} the origin and \signal{}
          location are identical. Hence such a ``PV'' would have identical
          \group{} and subsystem IDs.

          On the other hand, an ``actuator'' \signal{} originates
          on a controller IOC targetting an actuator IOC.
          Therefore, the \group{} (controller IOC) ID and
          subsystem (actuator IOC) IDs would
          be different.
        }

  \subsubsection{Alternative}
  From the previous sections it should have become obvious
  that grouping considerably complicates the general concept
  and the API. 

  If performance is sufficient, every \signal{} could simply
  be assigned a single \group{} and the whole issue would
  go away.

  When configuring the IDs there would be no need to define
  groups and the API for transmitting data would be symmetrical
  to the receiving counterpart without any need for explicitly
  assembling groups.

  Finally, without grouping an actuator could simply read
  a particular signal without having to switch subscription
  when an application controlling a different set of actuators
  is started. This would eliminate any conceptual difference
  between detectors, controllers and actuators.

  As a compromise, detector signals could still be \group{}ed
  while assigning every actuator signal it's own ID.

  \subsection{API}
  The C programming language according to the standard C99
  shall be used.
  The API to \fcom{} is defined in a header file {\tt fcom\_api.h}
  (see appendix~\ref{app:api}) which
  shall be protected from multiple inclusion and shall be usable from C++.

  Most routines return an error status with zero indicating success
  and nonzero an error condition. The return value specifies the type
  of error encountered.
    \subsubsection{Data Types}
      \fcom{} defines data types for IDs and \blob{}s. A
      \blob{} is a C {\tt struct} containing a protocol version,
      ID, type, count, timestamp, status and a pointer to
      the data array.

      \note{The application {\em must} set the version, ID, type and count
      fields as well as the pointer to the ``payload'' data array
      before handing a \blob{} to \fcom{}.}

      The timestamp,
      status and actual data are not interpreted or used by \fcom{}.
      Their semantics are defined by the application.
    \subsubsection{Error Handling}
      All \fcom{} routines which possibly can fail return an \cstl{int}
      value. A return value less than zero indicates failure. The
      possible error status values are defined in the \cstl{<fcom\_api.h>}
      header. Successful execution is indicated by a return value of 
      zero.

      In some cases and \fcom{} routine may fail due to an error
      at a lower level, in many cases a system error. If the lower
      level flags an error reason by means of the \cstl{errno} 
      variable then the \cstl{errno} value is encoded into
      the \fcom{} routine return value and may be retrieved using
      the \cstl{FCOM\_ERR\_SYS\_ERRNO(status)} macro.
      Another macro, \cstl{FCOM\_ERR\_IS\_SYS(status)} allows
      the application to test if in fact there is such an encoded
      \cstl{errno} value.

      A routine
      \begin{verbatim}
  const char * fcomStrerror(int fcom_error_status);
      \end{verbatim}
      converts an error status into a human-readable ASCII-string.
    \subsubsection{Subscription}
      Before an application is able to read data from the cache
      it must subscribe with a call to
      \begin{verbatim}
  int fcomSubscribe(FcomID id, int mode);
      \end{verbatim}
      providing the ID of the desired \blob{}. Subscription is
      not a ``real-time'' operation -- an unspecified amount of
      time may elapse before data are cached.

      The \cstl{mode} argument normally is \cstl{FCOM\_ASYNC\_GET}.
      Optionally, the implementation may implement \cstl{FCOM\_SYNC\_GET}.
      In this mode, \cstl{fcomGetBlob()} may (depending on
      it's \cstl{timeout\_ms} argument) block until new
      data arrive.

      \cstl{fcomSubscribe(id,FCOM\_SYNC\_GET)} returns
      \cstl{FCOM\_ERR\_UNSUPP} if the implementation does not support
      synchronous operation%
\footnote{
The expression
{\tt (FCOM\_ERR\_UNSUPP != fcomSubscribe(FCOM\_ID\_ANY, FCOM\_SYNC\_GET))}
is a possible run-time test for the availability of the
synchronization feature%
}.

      \note{\cstl{id}s subscribed for synchronous operation
      may consume more resources than ordinary asynchronous
      subscriptions.}

      In order to conserve resources an application should
      unsubscribe a \blob{} when it is no longer needed.

      \begin{verbatim}
  int fcomUnsubscribe(FcomID id);
      \end{verbatim}
    \subsubsection{Reception}
      \fcom{} maintains a cache of the data it receives from
      the network. Applications can obtain a pointer to the
      cached data using
      \begin{verbatim}
  int fcomGetBlob(FcomID id, FcomBlobRef *pp_blob, uint32_t timeout_ms);
      \end{verbatim}
      \note{Applications {\em must not} alter the
      contents of the data; they are only allowed to read
      them.}

      When fresh data arrive these are stored in a {\em different
      area} so that the application does not have to worry
      about locking the \blob{} or it being updated while
      the application is accessing it. I.e., the sequence
      \begin{verbatim}
  FcomBlobRef before, after;

  fcomGetBlob( SOME_ID, &before, 0 );

  /* NEW DATA ARRIVE HERE */

  fromGetBlob( SOME_ID, &after, 0 );
      \end{verbatim}
      yields two different pointers {\tt before} and
      {\tt after}. Applications can use the timestamp fields
      to determine if the data are ``fresh enough''.

      The \cstl{timeout\_ms} argument is normally set to
      zero which is equivalent to {\em asynchronous} operation.
      If the \cstl{id} was subscribed for {\em synchronous}
      operation with a \cstl{mode=FCOM\_SYNC\_GET} then
      \cstl{fcomGetBlob()} accepts a nonzero \cstl{timeout\_ms}
      argument. The routine then blocks for the given amount
      of milli-seconds or until fresh data arrive -- whichever
      occurs first. The return value is \cstl{FCOM\_ERR\_TIMEDOUT}
      if no data arrive during the timeout period.
      A given \cstl{id} {\em must} have been explicitly (and
      successfully) subscribed for synchronous operation --
      otherwise an attempt to call \cstl{fcomGetBlob()} with
      a non-zero timeout yields \cstl{FCOM\_ERR\_UNSUPP}.
      Executing \cstl{fcomGetBlob()} with a zero timeout 
      argument is possible and effectively (i.e., in terms
      of execution time) equivalent for either mode that
      was specified for subscription.
      \note{A synchronous \cstl{fcomGetBlob()} is {\em
      not atomical} with respect to blocking for data arriving
      and retrieving them.}
      It only guarantees that the data
      returned to the caller arrived after \cstl{fcomGetBlob()}
      was called. It is theoretically possible that the blob
      is updated more than once before the caller is scheduled
      to execute and retrieve the blob -- this possible scenario
      depends e.g., on the task-priority of the caller and CPU
      load etc. A synchronous \cstl{fcomGetBlob()} does guarantee,
      however, that the blob was updated {\em at least once}
      since the routine was started. As in asynchronous mode
      the caller may use e.g., the blob's timestamp to determine
      if data are ``valid'' or ``fresh enough''.

      Applications must release a \blob{} when it
      is no longer needed so that \fcom{} can free
      up resources:

      \begin{verbatim}
  fcomReleaseBlob( &before );
  fromReleaseBlob( &after );
      \end{verbatim}
    \subsubsection{Sets}
      The features and entry points described in this subsection are {\em optional},
      i.e., they need to be enabled at compile-time and might require the availability
      of certain system services.

      \Set{}s are very useful if a single thread needs to obtain fresh
      data for a number of IDs. Without \set{}s the application either must
      spawn multiple threads and let each one block for fresh data
      with a synchronous \cstl{fcomGetBlob()} and finally synchronize
      with a 'master-thread' or it must delay until it can be assumed
      that fresh data have arrived and then use asynchronous \cstl{fcomGetBlob()}s
      in order to read the data.

      Using \set{}s, the application first builds a \set, then blocks
      for the \set{} to ``fill'', i.e., for data to arrive for all member IDs
      and then resumes execution with the \set{} now being populated with
      new \blob{}s.

      \begin{verbatim}
FcomID         member_id[] = { ID1, ID2 };
FcomBlobSetRef theSet;
fcomAllocBlobSet( member_id, 2, &theSet );
      \end{verbatim}
      creates a \set{} with two members and returns a handle in \cstl{theSet}.
      Note that all IDs must already be subscribed (but it is {\em not} necessary for
      them to be subscribed for synchronous operation).

      The call returns zero on success and nonzero if an error occurs (returning
      a standard \fcom{} error code). The \set{} handle is invalid if the call
      fails.

      Note that an ID cannot be completely unsubscribed (i.e., the ``nest-count''
      cannot drop to zero) while being member of any \set.

      \cstl{fcomGetBlobSet()} suspends execution of the calling thread until
      either the desired members update or a timeout occurs, whichever happens
      first.

      \begin{verbatim}
FcomBlobSetMask got;
FcomBlobSetMask waitfor = (1<<0) | (1<<1);
int             flags   = FCOM_SET_WAIT_ALL;
fcomGetBlobSet( theSet, &got, waitfor, flags, timeout_ms);
      \end{verbatim}

      When the routine returns (successfully) then the \set{} is populated with new \blob{}s
      which can be accessed via the \set{} data structure:

      \begin{verbatim}
typedef struct FcomBlobSetMemb {
        FcomID                  idnt;
        FcomBlobRef             blob;
        FcomBlobSetHdrRef       head; /* for INTERNAL USE ONLY */
        FcomBlobSetMembRef      next; /* for INTERNAL USE ONLY */
} FcomBlobSetMemb;
 
typedef struct FcomBlobSet_ {
        unsigned            nmemb;
        FcomBlobSetMemb     memb[];
} FcomBlobSet, *FcomBlobSetRef;
      \end{verbatim}

      The members of the \set{} preserve the same order that the ``member\_id'' array
      had when the \set{} was created. E.g., ID2 has member index 1 and thus the
      associated blob could be accessed as
      \begin{verbatim}
theSet->memb[1].blob
      \end{verbatim}
      (the \cstl{theSet->nmemb} field stores the number of members of the set which would
      be 2 in our example).

      The blocking behavior is determined by the \cstl{waitfor} and \cstl{flags} 
      (and the \cstl{timeout_ms}) arguments. The \cstl{waitfor} argument (and also the value
      returned in \cstl{got}) is a {\em bitmask} with each bit \cstl{1<<i} 
      representing a member \cstl{i}.
     
      \begin{itemize}
        \item If \cstl{flags} has \cstl{FCOM\_SET\_WAIT\_ALL} set then the call
              only returns when {\em all} members with their bit set in \cstl{waitfor}
              have updated.
        \item If \cstl{flags} has \cstl{FCOM\_SET\_WAIT\_ALL} clear
              (\cstl{FCOM\_SET\_WAIT\_ANY}) then the call returns as soon as {\em at least
              one} member with its bit set in \cstl{waitfor} has updated.
        \item A bitset flagging all updated members is returned to the \cstl{got}
              variable. If this returned value is of no interest then a NULL pointer 
              may be passed.
        \item \Blob{}s ``attached'' to the \set{} logically ``belong'' to the \set,
              i.e., they are released automatically either when members update
              as a result of passing the same \set{} again to \cstl{fcomGetBlobSet()}
              or when destroying the \set{} (\cstl{fcomFreeBlobSet()}).

              The application may ``take over'' a \blob{} reference by setting
              the \cstl{blob} field to NULL but it is then responsible for releasing
              the \blob.
\begin{verbatim}
FcomBlobRef my_blob  = theSet->memb[1].blob;
theSet->memb[1].blob = 0;
fcomFreeBlobSet( theSet ); /* member # 0 is released automatically */
fcomReleaseBlob( &my_blob );
\end{verbatim}
        \item Only members with their bit set in \cstl{waitfor} will have their
              \cstl{blob} field updated.
        \item If the routine times out then still a subset of the requested members
              might have updated (and this would be reflected in the returned \cstl{got}
              variable).
        \item \Set{}s are ``single-threaded'' objects, i.e., it is a programming error
              to let multiple threads pass the same \set{} to \cstl{fcomGetBlobSet()}
              simultaneously.
        \item It is legal to re-use an existing \set{}, i.e., to repeatedly pass it to
              \cstl{fcomGetBlobSet()} --- ``attached'' blobs are manged automatically.
        \item \Blob{} references ``attached'' to a \set{} only change when the \set{}
              is again passed to \cstl{fcomGetBlobSet()} (or destroyed).
      \end{itemize}

      A \set{} is destroyed and all associated resources released with
      \begin{verbatim}
fcomFreeBlobSet( theSet );
      \end{verbatim}
      and in particular are all ``attached'' \blob{}s released by this routine.

    \subsubsection{Sets vs. Synchronous Get Operations}
      Both, \set{}s and synchronous \cstl{fcomGetBlob()} operations synchronize
      the execution of the calling thread with the arrival of new data. However,
      they serve different purposes:
      \begin{itemize}
        \item \Set{}s are optimal if a single thread wants to wait for multiple \blob{}s.
        \item Synchronous \cstl{fcomGetBlob()}s are used when multiple threads simultaneously
              need to wait for a single \blob.
      \end{itemize}

    \subsubsection{Transmission}
      An endpoint who wishes to transmit data must first
      allocate a group:
      \begin{verbatim}
  status = fcomAllocGroup( SOME_ID, &my_group );
      \end{verbatim}
      The group-part of the ID passed to this routine
      defines the group ID. All \blob{}s of data subsequently
      added to this \group{} must belong to the same \group{},
      i.e., the GID-part of their IDs must match.

      It is admissible to pass \cstl{FCOM\_ID\_ANY} in which
      case the GID of the group is defined by the first
	  blob added with a GID different from \cstl{FCOM\_GID\_ANY}.

      Data \blob{}s are added to the group by calling
      \begin{verbatim}
  FcomBlob a_blob;
  double   val;

  a_blob.fc_vers = FCOM_PROTO_VERSION;
  a_blob.fc_idnt = MY_BLOB_ID; 
  a_blob.fc_type = FCOM_EL_DOUBLE;
  a_blob.fc_nelm = 1;
  a_blob.fc_dbl  = &val;
  
  val = 1.2345;

  status = fcomAddGroup(my_group, &a_blob);
      \end{verbatim}
      \note{The protocol version, ID, type and element
      count as well as the data pointer of the \blob{}
      must be set correctly before calling this routine.}
      {\tt fcomAddGroup()} is then executed repeatedly
      to assemble the \group{}.

      It is admissible for the GID part of the ID to
      be \cstl{FCOM\_GID\_ANY} in which case it is defined
      by the group.

      Eventually, the \group{} is transmitted by
      \begin{verbatim}
  status = fcomPutGroup(my_group);
      \end{verbatim}
      \note{At this point, \fcom{} takes over 
      ``ownership'' of the group and associated resources
      ({\tt fcomAddGroup()} copies the data \blob{}s
      into the \group{} container, i.e., the user is
      free so reuse the \blob{} data structure and data 
      array area after calling {\tt fcomAddGroup()}).}

      If a \group{} is not sent, i.e., if the
      user decides not to execute {\tt fcomPutGroup()}
      then the \group{} can be destroyed by
      calling
      \begin{verbatim}
  fcomFreeGroup(my_group);
      \end{verbatim}
      \note{It is a programming error to call {\tt fcomFreeGroup()}
            passing a \group{} that had already been given to
            {\tt fcomPutGroup()} -- regardless of the status
            returned by the latter.}
    \subsubsection{Statistics}
      The following entry points for obtaining statistics information are
      provided:
      \begin{verbatim}
  void fcomDumpStats(FILE *f);
      \end{verbatim}
      prints user-readable information to a \cstl{stdio}-stream
      \cstl{f}, which may be \cstl{NULL}, in which case
      the \cstl{stdout} is used.

      In some cases it is desirable for the application to obtain
      specific information in numerical format. For these cases
      the routine
      \begin{verbatim}
  int fcomGetStats(int n_keys, uint32_t key_arr[], uint64_t value_arr[]);
      \end{verbatim}
      was implemented. This routine retrieves a bunch of values
      corresponding to a number of ``keys''. The user submits an
      array of dimension \cstl{n\_keys} of numerical ``keys''
      as well as a ``response''-array (of the same dimension) which
      designates a storage area for the routine to deposit the
      values associated with the given keys.

      The recognized keys corresponding to specific information
      are defined in the \cstl{<fcom\_api.h>} header.
 
      \note{The returned information is valid only if the
      routine returns zero, i.e., if {\em all} supplied keys
      were recognized.}

      Currently, all internal counters are 32-bit wide. The
      routine uses 64-bit values for sake of future enhancements.

      \note{The implementation may rely on 32-bit counters
      being accessed/copied consistently/atomically by the CPU and thus
      may not use any mutual exclusion mechanism to read counters.}

      This means that values corresponding to multiple keys
      may not be read in an atomical fashion -- even though
      they were supplied to the same call, e.g.:
      \begin{verbatim}
  uint32_t keys[2] = {
    FCOM_STAT_RX_NUM_BLOBS_RECV,
    FCOM_STAT_RX_NUM_BLOBS_RECV
  };
  uint64_t vals[2];
  fcomGetStats(2, keys, vals);
  if ( vals[1] != vals[2] )
    printf("No surprise\n");
      \end{verbatim}
      asks for the same key -- the number of \blob{}s received --
      twice. However, it is possible that the two returned values
      differ since a new \blob{} might have arrived/been processed
      between reading the counter twice.

      \begin{verbatim}
  int fcomDumpIDStats( FcomID idnt, int level, FILE *f);
      \end{verbatim}

	  prints statistics and contents of a cached \blob{} with
      ID 'idnt' to a FILE. The FILE handle may be NULL in
      which case stdout is used. 

	  If 'level' is nonzero then more verbose information
      is dumped including the payload data.

	  This routine is a useful diagnostic to check if data are received
      at all and if they update etc.

    \subsubsection{Initialization}
      Before utilizing \fcom{} an application must initialize
      the facility using
      \begin{verbatim}
  int fcomInit(const char *mcast_g_prefix, unsigned n_bufs);
      \end{verbatim}
      The \cstl{mcast\_g\_prefix} argument is a string of
      the format
      \begin{verbatim}
  <multicast IP prefix> [ ':' <port number> ]
      \end{verbatim}
      The multicast IP prefix must be a (valid) multicast
      IP address that must not overlap the range
      \cstl{FCOM\_GID\_MIN}..\cstl{FCOM\_GID\_MAX}. This
      prefix is used for all transactions by all data
      sinks and sources. An optional port number may
      also be specified. If no port number is given then
      \cstl{FCOM\_PORT\_DEFLT} is used.

      \note{All nodes participating in \fcom{} {\em must} use the
      same prefix and port number.}

      The \cstl{n\_bufs} argument is used to configure the
      number of buffers for \blob{}s \fcom{} should create.
      Buffers are only used by an \fcom{} receiver. Hence,
      setting \cstl{n\_bufs} to zero indicates that the
      receiver is unused -- this is recommended for applications
      that only wish to transmit data because memory and
      the \fcom{} port number can be saved%
\footnote{Since it is usually not possible to let multiple
applications running on a single node use the same port it
is desirable, e.g., on a linux system with different
processes executing an \fcom{} receiver and an \fcom{}
transmitter, respectively, to instruct the transmitter
{\em not} to attempt to use the reserved \fcom{} port since
that may prevent the receiver process from using it.}.

      Each \blob{} that \fcom{} receives is stored in
	  a buffer which is released when the last reference
      to a \blob{} is surrendered with \cstl{fcomReleaseBlob()}.

      Buffers are managed in pools of different sizes
      (e.g., 64, 128, 512 and 2048 bytes but the exact
      amount of pools and their sizes can be determined
      using \cstl{fcomDumpStats()} or \cstl{fcomGetStats()}).
      The \cstl{n\_bufs} argument defines the total
      number of buffers that are made available. This
      number is divided up among the different pools with
      pools for smaller-sized buffers being allocated a
      bigger number of buffers.

      Every subscribed \blob{} requires one buffer
      which remains ``alive'' as long as a reference
      to the \blob{} exists. Hence, \cstl{n\_bufs}
      should be chosen according to the application's
      needs.
     
\section{Presentation Layer}
We propose to use the {\em XDR} format. All data are encoded
to XDR before being sent and decoded after being received.
This ensures interoperability of different host architectures
at a relatively low cost, at least on machines which use the
IEEE floating-point representation.

\section{Transport Layer}
We propose to use the UDP protocol without computing a checksum
(relying on the link-level checksum computed/checked by Ethernet hardware).

\note{The size of UDP messages shall be restricted to
fit an Ethernet frame.}

A {\em unique port number} must be assigned to \fcom{}. This port
number must not be used for any other service than \fcom{}
(on the network used by \fcom{}).
The reason is that following standard ``socket'' semantics
multicast frames are filtered at the {\em interface} not at the
socket. I.e., even though an interested receiver subscribes
to a multicast group using BSD {\tt setsockopt()} the
group address is set on the interface, not the socket%
\footnote{
The consequence is that e.g., if application A1 receives
from port P1 and application A2, which
had subscribed to multicast traffic from G2, receives on
port P2 then A1 still receives traffic sent to G2:P1
(even though A1 had not subscribed to group G2).
}.

\section{Network, Link and Physical Layer}
State-of-the-art Gigabit Ethernet technology with a
standard (non-jumbo) frame size shall be employed.

A minimal, {\em non-standard} (because of missing support for
features such as fragmentation, options and others) IP protocol
header is added. As explained in the next section, minimal support
for IP is mandated by the requirement of IGMP support.

Besides that, employing IP is useful
for debugging and testing purposes so that the \fcom{}
protocol stack can be tested in a regular networking environment
where many tools are available.

\subsection{Multicasting}
The main distribution mechanism for \fcom{} is {\em Ethernet Multicast}
which must ensure that messages are delivered only to interested
nodes. This is accomplished by using a switched network which
is able to save bandwidth when multicast is used.

However,
manual configuration of all required multicast delivery
paths into the switches is extremely cumbersome and error-prone
and shall therefore be avoided.

State-of-the art switches usually implement {\em IGMP snooping},
a technique
which automatically takes care of maintaining the multicast
distribution paths up to date and pruning ports where appropriate.
Note, however, that the IGMP
protocol is at {\em level 3} and therefore {\em requires}
a minimal IP infrastructure. Note that RFC4541 (2.1.2.4) states
that
\begin{quotation}
\noindent
"All non-IPv4 multicast packets should continue to be
flooded out to all remaining ports in the forwarding state..."
\end{quotation}
and also (2.1.2.5)
\begin{quotation}
\noindent
"IP address based forwarding is preferred...".
\end{quotation}

Hence, \fcom{} shall implement minimal IP and IGMP-v2.
The network hardware infrastructure shall provide the
appropriate switches and router or querier.

\appendix
\pagebreak
\section*{Appendix}

\section{The \fcom{} API Header}
\label{app:api}
%\scriptsize
%\verbatiminput{fcom_api.h}
\lstset{basicstyle=\scriptsize, formfeed=\pagebreak}
\lstinputlisting{fcom_api.h}
\end{document}
